module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/@opentelemetry/api [external] (next/dist/compiled/@opentelemetry/api, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/@opentelemetry/api", () => require("next/dist/compiled/@opentelemetry/api"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[project]/app/api/analyze/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "POST",
    ()=>POST,
    "dynamic",
    ()=>dynamic,
    "revalidate",
    ()=>revalidate,
    "runtime",
    ()=>runtime
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$server$2d$only$2f$empty$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/server-only/empty.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@supabase/supabase-js/dist/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/ws/wrapper.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/index.mjs [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__ = __turbopack_context__.i("[project]/node_modules/openai/client.mjs [app-route] (ecmascript) <export OpenAI as default>");
var __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/crypto [external] (crypto, cjs)");
;
;
;
;
;
;
const runtime = "nodejs";
const dynamic = "force-dynamic";
const revalidate = 0;
const TF_ORDER = [
    "5m",
    "15m",
    "1h",
    "4h",
    "12h",
    "1d",
    "3d"
];
const TF_ORDER_INDEX = new Map(TF_ORDER.map((tf, i)=>[
        tf,
        i
    ]));
const TF_MS = {
    "5m": 5 * 60 * 1000,
    "15m": 15 * 60 * 1000,
    "1h": 60 * 60 * 1000,
    "4h": 4 * 60 * 60 * 1000,
    "12h": 12 * 60 * 60 * 1000,
    "1d": 24 * 60 * 60 * 1000,
    "3d": 3 * 24 * 60 * 60 * 1000
};
/* ===================== ENV + CLIENTS ===================== */ function requireEnv(name) {
    const v = process.env[name];
    if (!v) throw new Error(`Missing env var: ${name}`);
    return v;
}
function sbAdmin() {
    const url = requireEnv("SUPABASE_URL");
    const key = requireEnv("SUPABASE_SERVICE_ROLE_KEY");
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$supabase$2f$supabase$2d$js$2f$dist$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createClient"])(url, key, {
        auth: {
            persistSession: false
        }
    });
}
function openaiClient() {
    const apiKey = requireEnv("OPENAI_API_KEY");
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openai$2f$client$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$export__OpenAI__as__default$3e$__["default"]({
        apiKey
    });
}
/* ===================== SMALL UTILS ===================== */ function clamp(n, lo, hi) {
    if (!Number.isFinite(n)) return lo;
    return Math.min(hi, Math.max(lo, n));
}
function uniq(arr) {
    return Array.from(new Set(arr));
}
function normalizeTimeframes(input) {
    if (!Array.isArray(input)) return [];
    const out = [];
    const seen = new Set();
    for (const raw of input){
        const tf = String(raw ?? "").trim().toLowerCase();
        if (!TF_ORDER_INDEX.has(tf)) continue;
        if (seen.has(tf)) continue;
        seen.add(tf);
        out.push(tf);
    }
    return out;
}
function sortTimeframes(tfs) {
    return [
        ...tfs
    ].sort((a, b)=>(TF_ORDER_INDEX.get(a) ?? 999) - (TF_ORDER_INDEX.get(b) ?? 999));
}
function safeNum(v) {
    if (v == null) return null;
    const n = typeof v === "number" ? v : Number(v);
    return Number.isFinite(n) ? n : null;
}
function stripCodeFences(s) {
    const t = (s ?? "").trim();
    // ```json ... ``` or ``` ... ```
    const fenced = t.match(/^```(?:json)?\s*([\s\S]*?)\s*```$/i);
    return fenced ? fenced[1].trim() : t;
}
function extractJsonObject(text) {
    const s = stripCodeFences(text).replace(/[\u201C\u201D]/g, '"').replace(/[\u2018\u2019]/g, "'").trim();
    // Fast path
    if (s.startsWith("{") && s.endsWith("}")) return s;
    // Find the outermost {...}
    const first = s.indexOf("{");
    const last = s.lastIndexOf("}");
    if (first >= 0 && last > first) return s.slice(first, last + 1);
    return null;
}
async function repairJsonWithModel(openai, model, schemaHint, bad) {
    const res = await openai.responses.create({
        model,
        temperature: 0,
        max_output_tokens: 1200,
        instructions: "You are a strict JSON repair tool. Convert the user's content into ONE valid JSON object that matches the provided schema hint. " + "Return ONLY JSON. No markdown, no code fences, no commentary.",
        input: JSON.stringify({
            schemaHint,
            bad
        })
    });
    return String(res.output_text ?? "").trim();
}
function toPerp(sym) {
    // DB stores symbols as perpetual contract tickers like BTCUSDT-PERP.
    // UI may send BTCUSDT. Normalize to the DB convention.
    const s = (sym || "").trim().toUpperCase();
    if (!s) return s;
    // If already in DB form, keep it.
    if (s.endsWith("-PERP")) return s;
    // Common alternates:
    // BTCUSDT_PERP, BTCUSDT-PERP, BTCUSDT.PERP -> normalize to BTCUSDT-PERP
    const normalized = s.replace(/[_\. ]?PERP$/i, "");
    return normalized + "-PERP";
}
function toWsSymbol(dbSymbol) {
    // Binance futures WS expects the base symbol without the "-PERP" suffix.
    return (dbSymbol || "").toLowerCase().replace(/-perp$/i, "");
}
function getTfSummary(tfData, tf) {
    return tfData.find((x)=>x.tf === tf && x.ok);
}
/* ===================== DATA ACCESS ===================== */ async function fetchCandles(sb, symbolPerp, tf, lookback) {
    const { data, error } = await sb.from("candles").select("symbol,timeframe,open_time,open,high,low,close,volume,buy_volume,sell_volume,trades,ema20,ema50,ema200,rsi14").eq("symbol", symbolPerp).eq("timeframe", tf).order("open_time", {
        ascending: false
    }).limit(lookback);
    if (error) throw new Error(`candles query failed: ${error.message}`);
    const rows = data ?? [];
    const normalized = rows.map((r)=>{
        const open = safeNum(r.open);
        const high = safeNum(r.high);
        const low = safeNum(r.low);
        const close = safeNum(r.close);
        const volume = safeNum(r.volume);
        const buy_volume = safeNum(r.buy_volume);
        const sell_volume = safeNum(r.sell_volume);
        if (open == null || high == null || low == null || close == null || volume == null || buy_volume == null || sell_volume == null) {
            return null;
        }
        return {
            symbol: r.symbol,
            timeframe: tf,
            open_time: r.open_time,
            open,
            high,
            low,
            close,
            volume,
            buy_volume,
            sell_volume,
            trades: Number(r.trades ?? 0),
            ema20: safeNum(r.ema20),
            ema50: safeNum(r.ema50),
            ema200: safeNum(r.ema200),
            rsi14: safeNum(r.rsi14)
        };
    }).filter((x)=>x != null).reverse(); // oldest -> newest
    return normalized;
}
async function fetchTfCounts(sb, symbolPerp, tfs) {
    const counts = {};
    // Naive approach: count via head query per tf.
    // If you have a materialized counts table, replace this.
    await Promise.all(tfs.map(async (tf)=>{
        const { count, error } = await sb.from("candles").select("symbol", {
            count: "exact",
            head: true
        }).eq("symbol", symbolPerp).eq("timeframe", tf);
        if (error) {
            counts[tf] = 0;
            return;
        }
        counts[tf] = Number(count ?? 0);
    }));
    return counts;
}
async function fetchNews(sb, symbolPerp, limit = 6) {
    try {
        const base = symbolPerp.replace(/-PERP$/i, "").replace(/USDT$/i, "").replace(/USD$/i, "");
        const or = base ? `symbols.cs.{${base}},symbols.cs.{CRYPTO},symbols.cs.{MACRO}` : "symbols.cs.{CRYPTO}";
        const { data, error } = await sb.from("market_news").select("title,url,source,published_at,symbols").or(or).order("published_at", {
            ascending: false
        }).limit(limit);
        if (error || !Array.isArray(data)) return [];
        return data.map((r)=>({
                title: String(r.title ?? ""),
                url: String(r.url ?? ""),
                source: r.source ?? null,
                published_at: r.published_at ?? null,
                symbols: Array.isArray(r.symbols) ? r.symbols : undefined
            }));
    } catch  {
        return [];
    }
}
async function persistDecision(sb, payload) {
    try {
        await sb.from("decision_logs").insert({
            id: payload.id,
            symbol: payload.symbol,
            mode: payload.mode,
            timeframes: payload.timeframes,
            lookback: payload.lookback,
            price: payload.price,
            price_live: payload.price_live,
            gate: payload.gate,
            setup: payload.setup,
            plan: payload.plan,
            verdict: payload.verdict,
            intraday: payload.intraday,
            data_health: payload.data_health,
            news: payload.news
        });
    } catch  {
    // ignore if table missing or insert fails
    }
}
/* ===================== CORE CALCS ===================== */ function computeRegime2(tf, rows) {
    // Simple score proxy: slope vs chop using EMA/RSI + candle overlaps.
    if (rows.length < 50) {
        return {
            label: "NA",
            trendScore: 0,
            chopScore: 100,
            reasons: [
                "insufficient_rows"
            ]
        };
    }
    const last = rows[rows.length - 1];
    const ema20 = last.ema20 ?? null;
    const ema50 = last.ema50 ?? null;
    const ema200 = last.ema200 ?? null;
    const rsi = last.rsi14 ?? null;
    let trendScore = 0;
    let chopScore = 0;
    const reasons = [];
    if (ema20 != null && ema50 != null) {
        const sep = Math.abs(ema20 - ema50) / last.close;
        trendScore += clamp(sep * 4000, 0, 50); // 0..50
        reasons.push(`ema20-ema50_sep=${(sep * 100).toFixed(2)}%`);
    } else {
        chopScore += 20;
        reasons.push("ema_missing");
    }
    if (ema50 != null && ema200 != null) {
        const sep = Math.abs(ema50 - ema200) / last.close;
        trendScore += clamp(sep * 2500, 0, 35);
        reasons.push(`ema50-ema200_sep=${(sep * 100).toFixed(2)}%`);
    }
    if (rsi != null) {
        const dist = Math.abs(rsi - 50);
        trendScore += clamp(dist * 1.2, 0, 20);
        reasons.push(`rsi_dist=${dist.toFixed(1)}`);
    }
    // Chop proxy: overlapping bodies/ranges in last N
    const N = 20;
    const tail = rows.slice(-N);
    let overlap = 0;
    for(let i = 1; i < tail.length; i++){
        const a = tail[i - 1];
        const b = tail[i];
        const lo = Math.max(a.low, b.low);
        const hi = Math.min(a.high, b.high);
        if (hi > lo) overlap++;
    }
    const overlapPct = overlap / Math.max(1, N - 1);
    chopScore += clamp(overlapPct * 100, 0, 80);
    reasons.push(`overlapPct=${(overlapPct * 100).toFixed(0)}%`);
    // normalize-ish
    trendScore = clamp(trendScore, 0, 100);
    chopScore = clamp(100 - trendScore + chopScore * 0.35, 0, 100);
    const label = trendScore >= 60 && chopScore <= 55 ? "TREND" : chopScore >= 65 ? "CHOP" : trendScore >= 50 ? "LEAN_TREND" : "MIXED";
    return {
        label,
        trendScore,
        chopScore,
        reasons
    };
}
function summarize(tf, rows) {
    try {
        if (!rows.length) return {
            ok: false,
            tf,
            n: 0,
            error: "no_rows"
        };
        const last = rows[rows.length - 1];
        const totalVol = rows.reduce((s, r)=>s + r.volume, 0);
        const buy = rows.reduce((s, r)=>s + r.buy_volume, 0);
        const sell = rows.reduce((s, r)=>s + r.sell_volume, 0);
        const imb = totalVol > 0 ? (buy - sell) / totalVol : 0;
        return {
            ok: true,
            tf,
            n: rows.length,
            price: last.close,
            ohlc: {
                open: last.open,
                high: last.high,
                low: last.low,
                close: last.close
            },
            ema: {
                ema20: last.ema20 ?? undefined,
                ema50: last.ema50 ?? undefined,
                ema200: last.ema200 ?? undefined
            },
            rsi14: last.rsi14 ?? undefined,
            volume: {
                total: totalVol,
                buy,
                sell,
                imbalance: imb
            },
            regime2: computeRegime2(tf, rows)
        };
    } catch (e) {
        return {
            ok: false,
            tf,
            n: rows.length,
            error: e?.message ?? "summarize_failed"
        };
    }
}
function computeATR(rows, period = 14) {
    if (rows.length < period + 1) return null;
    let sum = 0;
    let count = 0;
    for(let i = rows.length - period; i < rows.length; i++){
        const c = rows[i];
        const prev = rows[i - 1];
        if (!prev) continue;
        const tr = Math.max(c.high - c.low, Math.abs(c.high - prev.close), Math.abs(c.low - prev.close));
        if (Number.isFinite(tr)) {
            sum += tr;
            count += 1;
        }
    }
    return count ? sum / count : null;
}
function buildChopPlan(rows15m, price, constraints) {
    const lookback = rows15m.slice(-48);
    if (lookback.length < 24 || !Number.isFinite(price) || price <= 0) {
        return {
            action: "NO_TRADE",
            leverage: 1,
            entry: {
                type: "market"
            },
            stop: {
                price,
                rationale: "chop_insufficient_data"
            },
            targets: [
                {
                    price,
                    sizePct: 100
                }
            ],
            riskPct: 0,
            notes: "chop_mode:insufficient_data",
            citations: []
        };
    }
    const hi = Math.max(...lookback.map((r)=>r.high));
    const lo = Math.min(...lookback.map((r)=>r.low));
    const mid = (hi + lo) / 2;
    const range = hi - lo;
    const atr = computeATR(rows15m, 14) ?? range * 0.1;
    const last = lookback[lookback.length - 1];
    const rsi = last.rsi14 ?? 50;
    const avgVol = lookback.reduce((s, r)=>s + r.volume, 0) / lookback.length;
    const volOk = avgVol > 0 ? last.volume >= avgVol * 0.7 : true;
    const tol = atr * 0.35;
    const touchesHi = lookback.filter((r)=>Math.abs(r.high - hi) <= tol).length;
    const touchesLo = lookback.filter((r)=>Math.abs(r.low - lo) <= tol).length;
    const rangeValid = touchesHi >= 2 && touchesLo >= 2;
    let action = "NO_TRADE";
    if (rangeValid && volOk && price <= lo + range * 0.33 && rsi <= 45) action = "LONG";
    if (rangeValid && volOk && price >= hi - range * 0.33 && rsi >= 55) action = "SHORT";
    if (action === "NO_TRADE") {
        return {
            action: "NO_TRADE",
            leverage: 1,
            entry: {
                type: "market"
            },
            stop: {
                price,
                rationale: "chop_no_edge"
            },
            targets: [
                {
                    price,
                    sizePct: 100
                }
            ],
            riskPct: 0,
            notes: `chop_mode:no_edge range_valid=${rangeValid} vol_ok=${volOk}`,
            citations: []
        };
    }
    const stop = action === "LONG" ? Math.max(0, lo - atr * 0.35) : hi + atr * 0.35;
    const t1 = action === "LONG" ? mid : mid;
    const t2 = action === "LONG" ? hi : lo;
    return {
        action,
        leverage: clamp(Math.min(3, constraints.maxLeverage), 1, constraints.maxLeverage),
        entry: {
            type: "market"
        },
        stop: {
            price: stop,
            rationale: "chop_range_stop"
        },
        targets: [
            {
                price: t1,
                sizePct: 60
            },
            {
                price: t2,
                sizePct: 40
            }
        ],
        riskPct: clamp(Math.min(0.6, constraints.maxRiskPct), 0.1, constraints.maxRiskPct),
        notes: `chop_mode:range hi=${hi.toFixed(1)} lo=${lo.toFixed(1)} rsi=${rsi.toFixed(1)} touches_hi=${touchesHi} touches_lo=${touchesLo} time_stop=6bars`,
        citations: []
    };
}
function computeTfHealth(tf, rows, nowMs) {
    const tfMs = TF_MS[tf];
    if (!rows.length) {
        return {
            tf,
            n: 0,
            lastOpenTimeMs: null,
            lastAgeMs: null,
            missingBars: 0,
            maxGapMs: 0,
            stale: true
        };
    }
    let missingBars = 0;
    let maxGapMs = 0;
    let prevMs = Date.parse(rows[0].open_time);
    for(let i = 1; i < rows.length; i++){
        const curMs = Date.parse(rows[i].open_time);
        const diff = curMs - prevMs;
        if (Number.isFinite(diff) && diff > tfMs * 1.5) {
            const miss = Math.max(0, Math.round(diff / tfMs) - 1);
            if (miss > 0) missingBars += miss;
            if (diff > maxGapMs) maxGapMs = diff;
        }
        prevMs = curMs;
    }
    const lastOpenTimeMs = Date.parse(rows[rows.length - 1].open_time);
    const lastAgeMs = Number.isFinite(lastOpenTimeMs) ? Math.max(0, nowMs - lastOpenTimeMs) : null;
    const stale = lastAgeMs != null ? lastAgeMs > tfMs * 2 : true;
    return {
        tf,
        n: rows.length,
        lastOpenTimeMs,
        lastAgeMs,
        missingBars,
        maxGapMs,
        stale
    };
}
function candleBodyRatio(c) {
    const range = c.high - c.low;
    if (range <= 0) return 0;
    return Math.abs(c.close - c.open) / range;
}
function trueRangeC(c, prevClose) {
    const hl = c.high - c.low;
    const hc = Math.abs(c.high - prevClose);
    const lc = Math.abs(c.low - prevClose);
    return Math.max(hl, hc, lc);
}
function atrSMA_rows(rowsAsc, period = 14) {
    const out = new Array(rowsAsc.length).fill(NaN);
    const tr = new Array(rowsAsc.length).fill(NaN);
    for(let i = 0; i < rowsAsc.length; i++){
        const prevClose = i === 0 ? rowsAsc[i].close : rowsAsc[i - 1].close;
        tr[i] = trueRangeC(rowsAsc[i], prevClose);
        if (i >= period - 1) {
            let sum = 0;
            for(let j = i - (period - 1); j <= i; j++)sum += tr[j];
            out[i] = sum / period;
        }
    }
    return out;
}
function findSwingHighs_rows(rowsAsc, L) {
    const swing = new Array(rowsAsc.length).fill(false);
    for(let i = L; i < rowsAsc.length - L; i++){
        const h = rowsAsc[i].high;
        let ok = true;
        for(let k = 1; k <= L; k++){
            if (rowsAsc[i - k].high >= h) {
                ok = false;
                break;
            }
            if (rowsAsc[i + k].high > h) {
                ok = false;
                break;
            }
        }
        swing[i] = ok;
    }
    return swing;
}
function findSwingLows_rows(rowsAsc, L) {
    const swing = new Array(rowsAsc.length).fill(false);
    for(let i = L; i < rowsAsc.length - L; i++){
        const l = rowsAsc[i].low;
        let ok = true;
        for(let k = 1; k <= L; k++){
            if (rowsAsc[i - k].low <= l) {
                ok = false;
                break;
            }
            if (rowsAsc[i + k].low < l) {
                ok = false;
                break;
            }
        }
        swing[i] = ok;
    }
    return swing;
}
function lastSwingLowBefore_rows(rowsAsc, swingLows, idx) {
    for(let i = idx; i >= 0; i--)if (swingLows[i]) return rowsAsc[i].low;
    return null;
}
function lastSwingHighBefore_rows(rowsAsc, swingHighs, idx) {
    for(let i = idx; i >= 0; i--)if (swingHighs[i]) return rowsAsc[i].high;
    return null;
}
function isDisplacement_row(c, atr, dir, dispMult, bodyMin) {
    if (!Number.isFinite(atr) || atr <= 0) return false;
    const range = c.high - c.low;
    if (range < atr * dispMult) return false;
    if (candleBodyRatio(c) < bodyMin) return false;
    if (dir === "UP" && !(c.close > c.open)) return false;
    if (dir === "DOWN" && !(c.close < c.open)) return false;
    return true;
}
/**
 * Deterministic Order Block detector:
 * - Find displacement candles (range >= ATR*mult + body dominance)
 * - Require follow-through (N candles) to avoid single-candle fakes
 * - Optional BOS confirmation (break last swing)
 * - OB = last opposite candle before displacement
 */ function detectOrderBlocks(rowsDesc, tf, opts) {
    const rowsAsc = [
        ...rowsDesc
    ].reverse(); // candles table is fetched DESC; OB detection is easier ASC
    const { atrPeriod = 14, swingL = tf === "15m" ? 2 : 3, lookbackForOrigin = tf === "15m" ? 5 : tf === "1h" ? 7 : 10, followN = 2, followMin = 1, dispMult = tf === "15m" ? 1.3 : tf === "1h" ? 1.2 : 1.1, bodyMin = 0.55, useBodyZone = true, bufferAtrPct = 0.05, scoreThreshold = 65, maxReturn = 12 } = opts ?? {};
    if (rowsAsc.length < Math.max(atrPeriod + 10, 60)) return [];
    const atr = atrSMA_rows(rowsAsc, atrPeriod);
    const swingHighs = findSwingHighs_rows(rowsAsc, swingL);
    const swingLows = findSwingLows_rows(rowsAsc, swingL);
    const obs = [];
    for(let d = 0; d < rowsAsc.length; d++){
        const a = atr[d];
        const cd = rowsAsc[d];
        const down = isDisplacement_row(cd, a, "DOWN", dispMult, bodyMin);
        const up = isDisplacement_row(cd, a, "UP", dispMult, bodyMin);
        if (!down && !up) continue;
        // Follow-through
        let follow = 0;
        let broke = false;
        for(let k = 1; k <= followN && d + k < rowsAsc.length; k++){
            const ck = rowsAsc[d + k];
            if (down && ck.close < ck.open) follow++;
            if (up && ck.close > ck.open) follow++;
            if (down && ck.low < cd.low) broke = true;
            if (up && ck.high > cd.high) broke = true;
        }
        if (follow < followMin && !broke) continue;
        // BOS confirmation
        let bos = false;
        if (down) {
            const lastSL = lastSwingLowBefore_rows(rowsAsc, swingLows, d - 1);
            if (lastSL != null && cd.close < lastSL) bos = true;
        } else {
            const lastSH = lastSwingHighBefore_rows(rowsAsc, swingHighs, d - 1);
            if (lastSH != null && cd.close > lastSH) bos = true;
        }
        // Origin candle (last opposite candle before displacement)
        let obIdx = null;
        for(let i = d - 1; i >= 0 && i >= d - lookbackForOrigin; i--){
            const c = rowsAsc[i];
            if (down && c.close > c.open) {
                obIdx = i;
                break; // last bull before dump
            }
            if (up && c.close < c.open) {
                obIdx = i;
                break; // last bear before rally
            }
        }
        if (obIdx == null) continue;
        const obC = rowsAsc[obIdx];
        const buf = Number.isFinite(a) && a > 0 ? a * bufferAtrPct : 0;
        let zoneLo;
        let zoneHi;
        if (useBodyZone) {
            zoneLo = Math.min(obC.open, obC.close) - buf;
            zoneHi = Math.max(obC.open, obC.close) + buf;
        } else {
            zoneLo = obC.low - buf;
            zoneHi = obC.high + buf;
        }
        // Mitigation + invalidation
        let touchCount = 0;
        let mitigated = false;
        let invalidated = false;
        for(let j = obIdx + 1; j < rowsAsc.length; j++){
            const cj = rowsAsc[j];
            const touched = cj.high >= zoneLo && cj.low <= zoneHi;
            if (touched) {
                touchCount++;
                mitigated = true;
            }
            if (down && cj.close > zoneHi + buf) {
                invalidated = true;
                break;
            }
            if (up && cj.close < zoneLo - buf) {
                invalidated = true;
                break;
            }
        }
        // Score (0..100)
        const dispStrength = Math.min(1, (cd.high - cd.low) / (a * dispMult)); // 0..1+
        const body = candleBodyRatio(cd);
        let score = 0;
        score += 40 * dispStrength;
        score += 25 * Math.min(1, body / bodyMin);
        score += bos ? 20 : 0;
        score += !mitigated ? 10 : touchCount === 1 ? 5 : 0;
        score -= invalidated ? 50 : 0;
        score = Math.max(0, Math.min(100, Math.round(score)));
        if (score < scoreThreshold || invalidated) continue;
        obs.push({
            tf,
            side: down ? "SUPPLY" : "DEMAND",
            createdTs: obC.open_time,
            impulseTs: cd.open_time,
            zoneLo,
            zoneHi,
            atrAtCreation: Number.isFinite(a) ? a : 0,
            bos,
            mitigated,
            touchCount,
            invalidated,
            score
        });
    }
    // Keep the most relevant / highest quality
    obs.sort((a, b)=>b.score - a.score);
    return obs.slice(0, maxReturn);
}
function detectSetup(input) {
    const { tf15m, tf1h, tf4h, price } = input;
    // Minimal strict detector: aligns EMA slope and RSI in 1h/4h + 15m trigger zone.
    // You can replace with your rulebook engine later; this is intentionally tight.
    const reasons = [];
    const last15 = tf15m.at(-1);
    const last1h = tf1h.at(-1);
    const last4h = tf4h.at(-1);
    if (!last15 || !last1h || !last4h) {
        return {
            ok: false,
            setupType: "NONE",
            structure: "MIXED",
            confidence: 0,
            bias: "NONE",
            entryZone: {
                lo: price,
                hi: price,
                kind: "market"
            },
            stop: {
                price,
                rationale: "missing_tf_rows"
            },
            targets: [],
            reasons: [
                "missing_tf_rows"
            ]
        };
    }
    const emaUp = (r)=>r.ema20 != null && r.ema50 != null ? r.ema20 > r.ema50 : false;
    const emaDn = (r)=>r.ema20 != null && r.ema50 != null ? r.ema20 < r.ema50 : false;
    const rsi = (r)=>r.rsi14 != null ? r.rsi14 : 50;
    const bias = emaUp(last4h) && emaUp(last1h) && rsi(last1h) >= 52 ? "LONG" : emaDn(last4h) && emaDn(last1h) && rsi(last1h) <= 48 ? "SHORT" : "NONE";
    if (bias === "NONE") {
        reasons.push("ema_rsi_not_aligned");
        return {
            ok: false,
            setupType: "NONE",
            structure: "MIXED",
            confidence: 45,
            bias: "NONE",
            entryZone: {
                lo: price,
                hi: price,
                kind: "market"
            },
            stop: {
                price,
                rationale: "no_alignment"
            },
            targets: [],
            reasons
        };
    }
    // Simple pullback zone around 15m ema20
    const e20 = last15.ema20 ?? price;
    const zonePct = 0.12;
    const zone = bias === "LONG" ? {
        lo: e20 * (1 - zonePct / 100),
        hi: e20 * (1 + zonePct / 100)
    } : {
        lo: e20 * (1 - zonePct / 100),
        hi: e20 * (1 + zonePct / 100)
    };
    const stop = bias === "LONG" ? Math.min(last15.low, last1h.low) : Math.max(last15.high, last1h.high);
    const t1 = bias === "LONG" ? price * 1.01 : price * 0.99;
    const t2 = bias === "LONG" ? price * 1.02 : price * 0.98;
    const confidence = 60 + Math.min(30, Math.abs(rsi(last1h) - 50));
    reasons.push(`bias=${bias}`);
    reasons.push(`rsi1h=${rsi(last1h).toFixed(1)}`);
    return {
        ok: true,
        setupType: "PULLBACK",
        structure: bias === "LONG" ? "BULL" : "BEAR",
        confidence: clamp(confidence, 0, 100),
        bias,
        entryZone: {
            lo: zone.lo,
            hi: zone.hi,
            kind: "limit"
        },
        stop: {
            price: stop,
            rationale: "below/above recent swing lows/highs (15m+1h)"
        },
        targets: [
            {
                price: t1,
                sizePct: 50,
                rationale: "T1 small extension"
            },
            {
                price: t2,
                sizePct: 50,
                rationale: "T2 extension"
            }
        ],
        reasons,
        debug: {
            ema20_15m: last15.ema20,
            ema50_15m: last15.ema50,
            ema20_1h: last1h.ema20,
            ema50_1h: last1h.ema50
        }
    };
}
/* ===================== LIVE WS PROBE ===================== */ async function binanceProbe(symbolPerp, durationMs, maxMessages) {
    const streamSymbol = toWsSymbol(symbolPerp);
    const url = `wss://fstream.binance.com/ws/${streamSymbol}@trade`;
    return new Promise((resolve)=>{
        const ws = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$ws$2f$wrapper$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"](url);
        const times = [];
        let messages = 0;
        let buy = 0;
        let sell = 0;
        let lastPrice;
        let lastTs;
        const started = Date.now();
        const finish = (err)=>{
            try {
                ws.close();
            } catch  {}
            const sampleMs = Date.now() - started;
            const diffs = [];
            for(let i = 1; i < times.length; i++)diffs.push(times[i] - times[i - 1]);
            diffs.sort((a, b)=>a - b);
            const p = (q)=>{
                if (!diffs.length) return 0;
                const idx = Math.min(diffs.length - 1, Math.floor(q * diffs.length));
                return diffs[idx];
            };
            const total = buy + sell;
            const imbalance = total > 0 ? (buy - sell) / total : 0;
            resolve({
                ok: !err,
                messages,
                interArrival: {
                    p50: p(0.5),
                    p95: p(0.95),
                    p99: p(0.99)
                },
                flow: {
                    buy,
                    sell,
                    imbalance
                },
                sampleMs,
                lastPrice,
                lastTs,
                error: err
            });
        };
        const timer = setTimeout(()=>finish(), durationMs);
        ws.on("message", (msg)=>{
            if (messages >= maxMessages) {
                clearTimeout(timer);
                return finish();
            }
            messages++;
            const now = Date.now();
            times.push(now);
            try {
                const j = JSON.parse(msg.toString());
                const qty = Number(j.q ?? 0);
                const isMaker = Boolean(j.m); // maker is seller in Binance trade stream
                const p = Number(j.p);
                const ts = Number(j.T);
                if (Number.isFinite(p)) lastPrice = p;
                if (Number.isFinite(ts)) lastTs = ts;
                if (isMaker) sell += qty;
                else buy += qty;
            } catch  {
            // ignore parse errors
            }
        });
        ws.on("error", (e)=>{
            clearTimeout(timer);
            finish(e?.message ?? "ws_error");
        });
        ws.on("close", ()=>{
            clearTimeout(timer);
            finish();
        });
    });
}
/* ===================== REGIME GATE ===================== */ function buildRegimeGate(tfData, tfCounts) {
    const reasons = [];
    // Choose HTF: prefer 1d if enough data, else 12h.
    const useDaily = (tfCounts["1d"] ?? 0) >= 120;
    const htfs = useDaily ? [
        "1d",
        "4h"
    ] : [
        "12h",
        "4h"
    ];
    const htfSummaries = htfs.map((tf)=>getTfSummary(tfData, tf)).filter(Boolean);
    if (htfSummaries.length < 2) {
        return {
            blocked: true,
            reasons: [
                "missing_htf"
            ],
            higherTimeframesUsed: htfs,
            strongHigherTrend: false
        };
    }
    // Hard gate: if HTF chop is high, block.
    const htfChop = htfSummaries.map((s)=>s.regime2.chopScore);
    const avgChop = htfChop.reduce((a, b)=>a + b, 0) / htfChop.length;
    if (avgChop >= 70) reasons.push(`htf_chop_high:${avgChop.toFixed(0)}`);
    // Strong trend if trendScore high and chop low.
    const avgTrend = htfSummaries.map((s)=>s.regime2.trendScore).reduce((a, b)=>a + b, 0) / htfSummaries.length;
    const strongHigherTrend = avgTrend >= 65 && avgChop <= 60;
    if (!strongHigherTrend) reasons.push(`htf_not_strong_trend:t=${avgTrend.toFixed(0)} c=${avgChop.toFixed(0)}`);
    const blocked = reasons.length > 0 && !strongHigherTrend;
    return {
        blocked,
        reasons,
        higherTimeframesUsed: htfs,
        strongHigherTrend
    };
}
/* ===================== RAG RULE RETRIEVAL ===================== */ async function retrieveRules(openai, sb, query) {
    // 1) embed query
    const emb = await openai.embeddings.create({
        model: process.env.OPENAI_EMBED_MODEL || "text-embedding-3-small",
        input: query
    });
    const v = emb.data?.[0]?.embedding;
    if (!v || !Array.isArray(v)) throw new Error("Embedding failed");
    // 2) vector search via RPC
    const { data, error } = await sb.rpc("match_rule_chunks", {
        query_embedding: v,
        match_count: 14,
        doc_names: null,
        chunk_types: null
    });
    if (error) throw new Error(`match_rule_chunks failed: ${error.message}`);
    return data ?? [];
}
/* ===================== OPENAI PLAN CALL ===================== */ async function callModel(openai, snapshot, rules, constraints, opts) {
    const model = opts.openai?.model || process.env.OPENAI_TRADE_MODEL || "gpt-4o-mini";
    const temperature = clamp(Number(opts.openai?.temperature ?? 0.15), 0, 1);
    const maxTokens = clamp(Number(opts.openai?.maxTokens ?? 900), 256, 2000);
    const wantIntraday = opts.mode === "LTF" || opts.mode === "FULL" || opts.mode === "LTF_ONLY";
    const jsonSchema = {
        name: "trade_plan",
        strict: true,
        schema: {
            type: "object",
            additionalProperties: false,
            properties: {
                action: {
                    type: "string",
                    enum: [
                        "NO_TRADE",
                        "LONG",
                        "SHORT"
                    ]
                },
                leverage: {
                    type: "number"
                },
                entry: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        type: {
                            type: "string",
                            enum: [
                                "market",
                                "limit",
                                "stop"
                            ]
                        },
                        price: {
                            type: "number"
                        },
                        trigger: {
                            type: "number"
                        }
                    },
                    required: [
                        "type"
                    ]
                },
                stop: {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        price: {
                            type: "number"
                        },
                        rationale: {
                            type: "string"
                        }
                    },
                    required: [
                        "price",
                        "rationale"
                    ]
                },
                targets: {
                    type: "array",
                    items: {
                        type: "object",
                        additionalProperties: false,
                        properties: {
                            price: {
                                type: "number"
                            },
                            sizePct: {
                                type: "number"
                            }
                        },
                        required: [
                            "price",
                            "sizePct"
                        ]
                    },
                    minItems: 1
                },
                riskPct: {
                    type: "number"
                },
                notes: {
                    type: "string"
                },
                citations: {
                    type: "array",
                    items: {
                        type: "object",
                        additionalProperties: false,
                        properties: {
                            rule_chunk_id: {
                                type: "string"
                            }
                        },
                        required: [
                            "rule_chunk_id"
                        ]
                    }
                },
                intraday: wantIntraday ? {
                    type: "object",
                    additionalProperties: false,
                    properties: {
                        mode: {
                            type: "string",
                            enum: [
                                "LTF",
                                "FULL",
                                "LTF_ONLY"
                            ]
                        },
                        timeframes: {
                            type: "array",
                            items: {
                                type: "string",
                                enum: [
                                    "4h",
                                    "1h",
                                    "15m"
                                ]
                            },
                            minItems: 1
                        },
                        bias: {
                            type: "string",
                            enum: [
                                "LONG",
                                "SHORT",
                                "NONE"
                            ]
                        },
                        setupType: {
                            type: "string",
                            enum: [
                                "NONE",
                                "TREND_CONTINUATION",
                                "PULLBACK",
                                "BREAKOUT"
                            ]
                        },
                        structure: {
                            type: "string",
                            enum: [
                                "BULL",
                                "BEAR",
                                "RANGE",
                                "MIXED"
                            ]
                        },
                        entries: {
                            type: "array",
                            items: {
                                type: "object",
                                additionalProperties: false,
                                properties: {
                                    tf: {
                                        type: "string",
                                        enum: [
                                            "15m",
                                            "1h"
                                        ]
                                    },
                                    type: {
                                        type: "string",
                                        enum: [
                                            "breakout",
                                            "pullback",
                                            "reversal"
                                        ]
                                    },
                                    entry: {
                                        type: "number"
                                    },
                                    stop: {
                                        type: "number"
                                    },
                                    targets: {
                                        type: "array",
                                        items: {
                                            type: "object",
                                            additionalProperties: false,
                                            properties: {
                                                price: {
                                                    type: "number"
                                                },
                                                sizePct: {
                                                    type: "number"
                                                }
                                            },
                                            required: [
                                                "price",
                                                "sizePct"
                                            ]
                                        },
                                        minItems: 1
                                    },
                                    invalidation: {
                                        type: "string"
                                    },
                                    rr: {
                                        type: "number"
                                    },
                                    notes: {
                                        type: "string"
                                    }
                                },
                                required: [
                                    "tf",
                                    "type",
                                    "entry",
                                    "stop",
                                    "targets",
                                    "invalidation",
                                    "rr"
                                ]
                            }
                        },
                        noTradeIf: {
                            type: "array",
                            items: {
                                type: "string"
                            }
                        },
                        notes: {
                            type: "string"
                        },
                        citations: {
                            type: "array",
                            items: {
                                type: "object",
                                additionalProperties: false,
                                properties: {
                                    rule_chunk_id: {
                                        type: "string"
                                    }
                                },
                                required: [
                                    "rule_chunk_id"
                                ]
                            }
                        }
                    },
                    required: [
                        "mode",
                        "timeframes",
                        "bias",
                        "setupType",
                        "structure",
                        "entries",
                        "noTradeIf",
                        "citations"
                    ]
                } : undefined
            },
            required: [
                "action",
                "leverage",
                "entry",
                "stop",
                "targets",
                "riskPct",
                "citations"
            ]
        }
    };
    const system = "You are a rules-driven trading engine. You MUST follow the retrieved rules and the deterministic gates. " + "You MUST NOT invent indicators or external prices. Only use prices/levels from snapshot candle data. " + "If rules conflict or the setup is unclear, return action=NO_TRADE. " + (snapshot?.gate?.blocked && opts.mode === "LTF_ONLY" ? "HTF regime gate is BLOCKED, but it is BYPASSED for LTF_ONLY mode. You may trade ONLY if LTF execution rules are satisfied with clear invalidation and RR. " : "") + "If action is LONG/SHORT you MUST include at least 2 citations with rule_chunk_id from provided rules. " + (wantIntraday ? "Also produce intraday execution entries for 4h->1h->15m..." : "");
    const payload = {
        snapshot,
        constraints,
        mode: opts.mode,
        ltfTimeframes: opts.ltfTimeframes,
        rules
    };
    let content = "";
    try {
        const res = await openai.responses.create({
            model,
            temperature,
            max_output_tokens: maxTokens,
            instructions: system,
            input: JSON.stringify(payload),
            text: {
                format: {
                    type: "json_schema",
                    name: jsonSchema.name,
                    schema: jsonSchema.schema,
                    strict: true
                }
            }
        });
        content = String(res.output_text ?? "");
    } catch  {
        // Fallback for older models/accounts that don't support json_schema
        const res = await openai.responses.create({
            model,
            temperature,
            max_output_tokens: maxTokens,
            instructions: system + " Return ONLY valid JSON.",
            input: JSON.stringify({
                ...payload,
                format_hint: "json",
                schema_hint: {
                    action: "NO_TRADE|LONG|SHORT",
                    leverage: "number",
                    entry: {
                        type: "market|limit|stop",
                        price: "number?",
                        trigger: "number?"
                    },
                    stop: {
                        price: "number",
                        rationale: "string"
                    },
                    targets: [
                        {
                            price: "number",
                            sizePct: "number"
                        }
                    ],
                    riskPct: "number",
                    notes: "string?",
                    citations: [
                        {
                            rule_chunk_id: "string"
                        }
                    ],
                    intraday: wantIntraday ? "{...}" : undefined
                }
            }),
            text: {
                format: {
                    type: "json_object"
                }
            }
        });
        content = String(res.output_text ?? "");
    }
    try {
        const extracted = extractJsonObject(content);
        if (!extracted) throw new Error("no_json_object");
        return JSON.parse(extracted);
    } catch  {
        // One repair attempt (common failure: markdown fences, trailing text)
        try {
            const repaired = await repairJsonWithModel(openai, model, jsonSchema?.schema ?? {}, content);
            const extracted2 = extractJsonObject(repaired);
            if (!extracted2) throw new Error("repair_no_json_object");
            return JSON.parse(extracted2);
        } catch  {
            return {
                action: "NO_TRADE",
                leverage: 1,
                entry: {
                    type: "market"
                },
                stop: {
                    price: snapshot?.price ?? 0,
                    rationale: "Model returned invalid JSON."
                },
                targets: [
                    {
                        price: snapshot?.price ?? 0,
                        sizePct: 100
                    }
                ],
                riskPct: 0,
                notes: "Invalid JSON from model.",
                citations: []
            };
        }
    }
}
/* ===================== VALIDATION ===================== */ function validate(plan, constraints, price) {
    const reasons = [];
    plan.leverage = clamp(Number(plan.leverage), 1, constraints.maxLeverage);
    plan.riskPct = clamp(Number(plan.riskPct), 0, constraints.maxRiskPct);
    if (plan.action === "NO_TRADE") {
        return {
            ok: true,
            reasons,
            rr: null
        };
    }
    const cites = plan.citations ?? [];
    if (cites.length < 2) reasons.push("missing_rule_citations");
    const entry = plan.entry?.type === "market" ? price : Number(plan.entry?.price ?? plan.entry?.trigger);
    const stop = Number(plan.stop?.price);
    const t1 = Number(plan.targets?.[0]?.price);
    if (!Number.isFinite(entry) || entry <= 0) reasons.push("invalid_entry");
    if (!Number.isFinite(stop) || stop <= 0) reasons.push("invalid_stop");
    if (!Number.isFinite(t1) || t1 <= 0) reasons.push("invalid_target_1");
    if (reasons.length) return {
        ok: false,
        reasons,
        rr: null
    };
    if (plan.action === "LONG" && stop >= entry) reasons.push("long_stop_not_below_entry");
    if (plan.action === "SHORT" && stop <= entry) reasons.push("short_stop_not_above_entry");
    const stopDist = Math.abs(entry - stop);
    if (stopDist <= 0) reasons.push("zero_stop_distance");
    const minStopPct = 0.15;
    if (stopDist / entry * 100 < minStopPct) reasons.push("stop_too_tight");
    const rr = stopDist > 0 ? Math.abs(t1 - entry) / stopDist : 0;
    if (!Number.isFinite(rr) || rr <= 0) reasons.push("invalid_rr");
    if (rr < constraints.minRR) reasons.push("rr_too_low");
    return {
        ok: reasons.length === 0,
        reasons,
        rr
    };
}
function validateIntraday(intraday, constraints, price) {
    if (!intraday) return {
        ok: true,
        reasons: [],
        entries: []
    };
    const reasons = [];
    const entries = (intraday.entries ?? []).map((e)=>{
        const entry = Number(e.entry);
        const stop = Number(e.stop);
        const t1 = Number(e.targets?.[0]?.price);
        const stopDist = Math.abs(entry - stop);
        const rr = stopDist > 0 ? Math.abs(t1 - entry) / stopDist : 0;
        return {
            ...e,
            rrComputed: rr
        };
    });
    if (!entries.length) reasons.push("intraday_no_entries");
    for (const e of entries){
        if (!Number.isFinite(e.entry) || e.entry <= 0) reasons.push("intraday_invalid_entry");
        if (!Number.isFinite(e.stop) || e.stop <= 0) reasons.push("intraday_invalid_stop");
        if (!Number.isFinite(e.rrComputed) || e.rrComputed <= 0) reasons.push("intraday_invalid_rr");
        if (e.rrComputed < constraints.minRR) reasons.push("intraday_rr_too_low");
        const minStopPct = 0.12; // slightly looser for LTF
        const stopDist = Math.abs(e.entry - e.stop);
        if (Number.isFinite(e.entry) && e.entry > 0 && stopDist / e.entry * 100 < minStopPct) reasons.push("intraday_stop_too_tight");
    }
    // soft check: intraday prices should be near current price (avoid nonsense far away)
    const maxDriftPct = 8;
    for (const e of entries){
        const drift = Math.abs(Number(e.entry) - price) / price * 100;
        if (Number.isFinite(drift) && drift > maxDriftPct) reasons.push("intraday_entry_too_far_from_price");
    }
    return {
        ok: reasons.length === 0,
        reasons,
        entries
    };
}
function computeExecutionSizing(plan, price, equityUsd) {
    if (plan.action === "NO_TRADE") return null;
    const notes = [];
    const side = plan.action;
    const entryPrice = plan.entry?.type === "market" ? price : Number(plan.entry?.price ?? plan.entry?.trigger);
    const stopPrice = Number(plan.stop?.price);
    if (!Number.isFinite(entryPrice) || entryPrice <= 0) return null;
    if (!Number.isFinite(stopPrice) || stopPrice <= 0) return null;
    const stopDistance = Math.abs(entryPrice - stopPrice);
    if (!Number.isFinite(stopDistance) || stopDistance <= 0) return null;
    const riskPct = clamp(Number(plan.riskPct), 0, 100);
    const riskUsdPlanned = Math.max(0, equityUsd * riskPct / 100);
    const leverage = clamp(Number(plan.leverage), 1, 100);
    const maxNotionalUsd = Math.max(0, equityUsd * leverage);
    // qty sizing: constrained by risk AND leverage cap
    const qtyByRisk = riskUsdPlanned > 0 ? riskUsdPlanned / stopDistance : 0;
    const qtyByLev = maxNotionalUsd > 0 ? maxNotionalUsd / entryPrice : 0;
    let qty = Math.min(qtyByRisk, qtyByLev);
    if (!Number.isFinite(qty) || qty <= 0) {
        notes.push("position_size_zero_or_invalid");
        return {
            equityUsd,
            leverage,
            entryPrice,
            stopPrice,
            side,
            maxNotionalUsd,
            qty: 0,
            notionalUsd: 0,
            effectiveLeverage: 0,
            riskPct,
            riskUsdPlanned,
            riskUsdActual: 0,
            stopDistance,
            expected: [],
            notes
        };
    }
    const notionalUsd = qty * entryPrice;
    const effectiveLeverage = equityUsd > 0 ? notionalUsd / equityUsd : 0;
    const riskUsdActual = qty * stopDistance;
    // normalize target sizing to 100%
    const targets = Array.isArray(plan.targets) ? plan.targets : [];
    const sumPct = targets.reduce((acc, t)=>acc + (Number(t.sizePct) || 0), 0);
    const normTargets = sumPct > 0 ? targets.map((t)=>({
            price: Number(t.price),
            sizePct: (Number(t.sizePct) || 0) / sumPct * 100
        })) : targets.map((t, i)=>({
            price: Number(t.price),
            sizePct: i === 0 ? 100 : 0
        }));
    const expected = normTargets.filter((t)=>Number.isFinite(t.price) && t.price > 0 && Number.isFinite(t.sizePct) && t.sizePct > 0).map((t)=>{
        const move = Math.abs(Number(t.price) - entryPrice);
        const rr = stopDistance > 0 ? move / stopDistance : 0;
        // PnL for linear perp: qty * price move * signed direction * (sizePct portion)
        const dir = side === "LONG" ? 1 : -1;
        const pnlPerUnit = (Number(t.price) - entryPrice) * dir;
        const pnlUsd = qty * pnlPerUnit * (Number(t.sizePct) / 100);
        return {
            targetPrice: Number(t.price),
            sizePct: Number(t.sizePct),
            pnlUsd,
            rr
        };
    });
    if (effectiveLeverage > leverage + 1e-9) notes.push("effective_leverage_exceeds_requested");
    if (notionalUsd > maxNotionalUsd + 1e-6) notes.push("notional_exceeds_leverage_cap");
    return {
        equityUsd,
        leverage,
        entryPrice,
        stopPrice,
        side,
        maxNotionalUsd,
        qty,
        notionalUsd,
        effectiveLeverage,
        riskPct,
        riskUsdPlanned,
        riskUsdActual,
        stopDistance,
        expected,
        notes
    };
}
async function POST(req) {
    try {
        const body = await req.json();
        const raw = (body.symbol || "").trim().toUpperCase();
        if (!raw) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: "symbol is required"
        }, {
            status: 400
        });
        const symbol = toPerp(raw);
        const mode = body.mode ?? (body.ltfPlan?.enabled ? "LTF" : "HTF");
        let ltfTimeframes = normalizeTimeframes(body.ltfPlan?.timeframes).filter((tf)=>tf === "4h" || tf === "1h" || tf === "15m");
        if (!ltfTimeframes.length) ltfTimeframes = [
            "4h",
            "1h",
            "15m"
        ];
        const runLtf = mode === "LTF" || mode === "FULL" || mode === "LTF_ONLY";
        const aggressive = Boolean(body.aggressive);
        const bypassHtfGate = mode === "LTF_ONLY" || aggressive;
        // user requested timeframes (default: the ones your UI expects)
        const requestedInput = normalizeTimeframes(body.timeframes);
        const requestedTfs = requestedInput.length ? requestedInput : runLtf ? [
            "15m",
            "1h",
            "4h"
        ] : [
            "15m",
            "1h",
            "4h",
            "1d"
        ];
        // summary lookback (for snapshot / regime classifier)
        const lookbackSummary = clamp(body.lookback ?? 300, 80, 1500);
        // setup detector needs more; don't depend on user passing 200+
        const lookbackSetup = Math.max(260, lookbackSummary);
        const equity = Number.isFinite(Number(body.equityUsd)) ? Number(body.equityUsd) : 100;
        const constraints = {
            maxLeverage: clamp(Number(body.constraints?.maxLeverage ?? 10), 1, 10),
            maxRiskPct: clamp(Number(body.constraints?.maxRiskPct ?? 1), 0.1, 5),
            minRR: clamp(Number(body.constraints?.minRR ?? 1.8), 1, 5)
        };
        const persist = Boolean(body.persist);
        const sb = sbAdmin();
        // counts first (adaptive HTF choice depends on 1D count)
        const tfCounts = await fetchTfCounts(sb, symbol, [
            "1d",
            "12h",
            "4h",
            "1h",
            "15m"
        ]);
        if (runLtf) {
            const minBars = clamp(Number(body.ltfPlan?.minBars ?? 120), 60, 1000);
            const missing = [
                "4h",
                "1h",
                "15m"
            ].filter((tf)=>(tfCounts[tf] ?? 0) < minBars);
            if (missing.length) {
                const reasons = [
                    `ltf_data_missing_or_insufficient:${missing.join(",")}`,
                    `minBars=${minBars}`
                ];
                const snapshot = {
                    symbol,
                    price: 0,
                    equity: Number.isFinite(Number(body.equityUsd)) ? Number(body.equityUsd) : 100,
                    constraints: {
                        maxLeverage: clamp(Number(body.constraints?.maxLeverage ?? 10), 1, 10),
                        maxRiskPct: clamp(Number(body.constraints?.maxRiskPct ?? 1), 0.1, 5),
                        minRR: clamp(Number(body.constraints?.minRR ?? 1.8), 1, 5)
                    },
                    counts: tfCounts,
                    gate: {
                        blocked: true,
                        reasons,
                        higherTimeframesUsed: [],
                        strongHigherTrend: false
                    },
                    setup: {
                        ok: false,
                        setupType: "NONE",
                        structure: "MIXED",
                        confidence: 0,
                        bias: "NONE",
                        entryZone: {
                            lo: 0,
                            hi: 0,
                            kind: "market"
                        },
                        stop: {
                            price: 0,
                            rationale: "ltf_data"
                        },
                        targets: [],
                        reasons
                    },
                    data_health: {
                        generatedAt: new Date().toISOString(),
                        timeframes: [],
                        missingOrStale: [
                            "4h",
                            "1h",
                            "15m"
                        ],
                        blocked: true
                    },
                    news: [],
                    timeframes: [],
                    orderBlocks: [],
                    live: {
                        ws: null
                    }
                };
                const plan = {
                    action: "NO_TRADE",
                    leverage: 1,
                    entry: {
                        type: "market"
                    },
                    stop: {
                        price: 0,
                        rationale: "ltf_data_missing"
                    },
                    targets: [
                        {
                            price: 0,
                            sizePct: 100
                        }
                    ],
                    riskPct: 0,
                    notes: reasons.join("; "),
                    citations: []
                };
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                    ok: true,
                    snapshot,
                    gate: snapshot.gate,
                    setup: snapshot.setup,
                    rules: [],
                    plan,
                    verdict: {
                        ok: true,
                        reasons,
                        rr: null
                    }
                }, {
                    status: 200
                });
            }
        }
        // ensure snapshot always includes the HTF set + setup tfs (so UI and gating are consistent)
        const useDaily = (tfCounts["1d"] ?? 0) >= 120;
        const htfs = useDaily ? [
            "1d",
            "4h"
        ] : [
            "12h",
            "4h"
        ];
        const setupTfs = [
            "15m",
            "1h",
            "4h"
        ];
        const timeframes = sortTimeframes(uniq([
            ...requestedTfs,
            ...htfs,
            ...setupTfs
        ]));
        // 1) Candles -> summaries
        const tfData = [];
        let price = 0;
        const tfRows = new Map();
        for (const tf of timeframes){
            const rows = await fetchCandles(sb, symbol, tf, lookbackSummary);
            tfRows.set(tf, rows);
            const s = summarize(tf, rows);
            tfData.push(s);
        }
        const nowMs = Date.now();
        const dataHealth = {
            generatedAt: new Date(nowMs).toISOString(),
            timeframes: timeframes.map((tf)=>computeTfHealth(tf, tfRows.get(tf) ?? [], nowMs)),
            missingOrStale: [],
            blocked: false
        };
        dataHealth.missingOrStale = dataHealth.timeframes.filter((h)=>h.n === 0 || h.missingBars > 0 || h.stale).map((h)=>h.tf);
        dataHealth.blocked = dataHealth.missingOrStale.length > 0;
        // prefer price from 15m then 1h then first ok
        const p15 = getTfSummary(tfData, "15m")?.price;
        const p1h = getTfSummary(tfData, "1h")?.price;
        const pAny = tfData.find((x)=>x.ok)?.price;
        price = Number(p15 ?? p1h ?? pAny ?? 0);
        if (!Number.isFinite(price) || price <= 0) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: false,
                error: "No usable candle data (price not resolved).",
                symbol,
                timeframes,
                tfData
            }, {
                status: 422
            });
        }
        // 2) Live WS probe
        const ws = await binanceProbe(symbol, clamp(body.wsProbe?.durationMs ?? 2000, 250, 8000), clamp(body.wsProbe?.maxMessages ?? 800, 50, 3000));
        const news = await fetchNews(sb, symbol, 6);
        // 3) Regime gate (adaptive HTF)
        const gate = buildRegimeGate(tfData, tfCounts);
        const allowChop = gate.reasons.some((r)=>r.startsWith("htf_chop_high"));
        // 4) Setup detector (candle-only)  strict pre-gate to prevent chop bleed
        const tf15mRows = await fetchCandles(sb, symbol, "15m", lookbackSetup);
        const tf1hRows = await fetchCandles(sb, symbol, "1h", lookbackSetup);
        const tf4hRows = await fetchCandles(sb, symbol, "4h", lookbackSetup);
        const setup = detectSetup({
            tf15m: tf15mRows,
            tf1h: tf1hRows,
            tf4h: tf4hRows,
            price
        });
        // Order Blocks (deterministic, from candles table). Note: fetchCandles() returns DESC; detectOrderBlocks() handles ordering.
        const orderBlocksAll = [
            ...detectOrderBlocks([
                ...tf15mRows
            ].reverse(), "15m"),
            ...detectOrderBlocks([
                ...tf1hRows
            ].reverse(), "1h"),
            ...detectOrderBlocks([
                ...tf4hRows
            ].reverse(), "4h")
        ];
        const obMap = new Map();
        for (const ob of orderBlocksAll){
            const k = `${ob.tf}|${ob.side}|${ob.createdTs}|${ob.zoneLo.toFixed(2)}|${ob.zoneHi.toFixed(2)}`;
            const prev = obMap.get(k);
            if (!prev || ob.score > prev.score) obMap.set(k, ob);
        }
        const orderBlocks = Array.from(obMap.values()).sort((a, b)=>b.score - a.score);
        // snapshot (always return this)
        const snapshot = {
            symbol,
            price,
            price_candle: price,
            price_live: Number.isFinite(ws.lastPrice) ? ws.lastPrice : null,
            price_live_ts: Number.isFinite(ws.lastTs) ? ws.lastTs : null,
            equity,
            constraints,
            counts: tfCounts,
            gate,
            setup,
            data_health: dataHealth,
            chop_mode: allowChop,
            chop_context: {
                range15m: tf15mRows.length ? {
                    hi: Math.max(...tf15mRows.slice(-48).map((r)=>r.high)),
                    lo: Math.min(...tf15mRows.slice(-48).map((r)=>r.low))
                } : null
            },
            news,
            timeframes: tfData,
            orderBlocks,
            live: {
                ws
            }
        };
        // Gate 0: data completeness
        if (dataHealth.blocked && !aggressive) {
            const reasons = dataHealth.missingOrStale.map((tf)=>`data_gap:${tf}`);
            const plan = {
                action: "NO_TRADE",
                leverage: 1,
                entry: {
                    type: "market"
                },
                stop: {
                    price,
                    rationale: "data_gap"
                },
                targets: [
                    {
                        price,
                        sizePct: 100
                    }
                ],
                riskPct: 0,
                notes: reasons.join("; "),
                citations: []
            };
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                snapshot,
                gate,
                setup,
                rules: [],
                plan,
                verdict: {
                    ok: true,
                    reasons,
                    rr: null
                }
            }, {
                status: 200
            });
        }
        // Gate 1: HTF regime
        if (gate.blocked && !bypassHtfGate) {
            if (allowChop) {
                const chopPlan = buildChopPlan(tf15mRows, price, constraints);
                if (chopPlan.action !== "NO_TRADE") {
                    const chopVerdict = validate(chopPlan, constraints, price);
                    const decisionId = persist ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])() : null;
                    if (persist && decisionId) {
                        await persistDecision(sb, {
                            id: decisionId,
                            symbol,
                            mode,
                            timeframes,
                            lookback: lookbackSummary,
                            price,
                            price_live: snapshot.price_live ?? null,
                            gate,
                            setup,
                            plan: chopPlan,
                            verdict: chopVerdict,
                            intraday: null,
                            data_health: dataHealth,
                            news
                        });
                    }
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                        ok: true,
                        decision_id: decisionId,
                        snapshot,
                        gate,
                        setup,
                        rules: [],
                        plan: chopPlan,
                        verdict: chopVerdict
                    }, {
                        status: 200
                    });
                }
            }
            const plan = {
                action: "NO_TRADE",
                leverage: 1,
                entry: {
                    type: "market"
                },
                stop: {
                    price,
                    rationale: "regime_gate"
                },
                targets: [
                    {
                        price,
                        sizePct: 100
                    }
                ],
                riskPct: 0,
                notes: gate.reasons.join("; "),
                citations: []
            };
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                snapshot,
                gate,
                setup,
                rules: [],
                plan,
                verdict: {
                    ok: true,
                    reasons: gate.reasons,
                    rr: null
                }
            }, {
                status: 200
            });
        }
        // Gate 2: deterministic setup (tight by design)
        const minSetupConfidence = aggressive ? 40 : 55;
        if (!aggressive && (!setup.ok || setup.confidence < minSetupConfidence) && !allowChop) {
            const reasons = [
                ...setup.ok ? [] : [
                    "no_deterministic_setup"
                ],
                ...setup.confidence < minSetupConfidence ? [
                    `setup_confidence_below_${minSetupConfidence}`
                ] : [],
                ...setup.reasons
            ];
            const plan = {
                action: "NO_TRADE",
                leverage: 1,
                entry: {
                    type: "market"
                },
                stop: {
                    price,
                    rationale: "setup_gate"
                },
                targets: [
                    {
                        price,
                        sizePct: 100
                    }
                ],
                riskPct: 0,
                notes: reasons.join("; "),
                citations: []
            };
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                snapshot,
                gate,
                setup,
                rules: [],
                plan,
                verdict: {
                    ok: true,
                    reasons,
                    rr: null
                }
            }, {
                status: 200
            });
        }
        // 5) RAG query (include setup + gate in query so retrieval is relevant)
        const ai = openaiClient();
        const newsSummary = news.slice(0, 4).map((n)=>`${n.title}${n.source ? ` (${n.source})` : ""}`).join(" | ");
        const retrievalQuery = `Rules for ${symbol}. Mode=${mode}${runLtf ? ` LTF=${ltfTimeframes.join("+")}` : ""}. ` + `HTF=${gate.higherTimeframesUsed.join("+")} strong=${gate.strongHigherTrend}. ` + `Setup=${setup.bias}/${setup.setupType} conf=${setup.confidence}. ` + `TF Regime2=` + `${tfData.map((x)=>x.ok ? `${x.tf}:${x.regime2.label} t=${x.regime2.trendScore.toFixed(0)} c=${x.regime2.chopScore.toFixed(0)}` : `${x.tf}:na`).join(" | ")}. ` + `${newsSummary ? `News=${newsSummary}. ` : ""}` + `LiveTape msgs=${ws.messages} ia_p95=${ws.interArrival.p95.toFixed(1)}ms flow_imb=${ws.flow.imbalance.toFixed(3)}. ` + `Need entry, stop, targets, invalidation, risk, leverage, explicit no-trade conditions. ` + `HTF_GATE=${gate.blocked ? "BLOCKED" : "OK"} bypass=${bypassHtfGate}. `;
        const rules = await retrieveRules(ai, sb, retrievalQuery);
        if (!rules.length) {
            const plan = {
                action: "NO_TRADE",
                leverage: 1,
                entry: {
                    type: "market"
                },
                stop: {
                    price,
                    rationale: "no_rules"
                },
                targets: [
                    {
                        price,
                        sizePct: 100
                    }
                ],
                riskPct: 0,
                notes: "No rules retrieved from RAG.",
                citations: []
            };
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                ok: true,
                snapshot,
                gate,
                setup,
                rules: [],
                plan,
                verdict: {
                    ok: false,
                    reasons: [
                        "no_rules_retrieved"
                    ],
                    rr: null
                }
            }, {
                status: 200
            });
        }
        // 6) Model plan + engine validate
        // Pass snapshot (includes setup + gate) + full rule chunks to model
        let plan = await callModel(ai, snapshot, rules, constraints, {
            mode,
            ltfTimeframes: ltfTimeframes,
            openai: body.openai
        });
        let verdict = validate(plan, constraints, price);
        if (allowChop && plan.action === "NO_TRADE") {
            const chopPlan = buildChopPlan(tf15mRows, price, constraints);
            if (chopPlan.action !== "NO_TRADE") {
                plan = chopPlan;
                verdict = validate(plan, constraints, price);
            }
        }
        const intradayVerdict = validateIntraday(plan.intraday, constraints, price);
        const decisionId = persist ? (0, __TURBOPACK__imported__module__$5b$externals$5d2f$crypto__$5b$external$5d$__$28$crypto$2c$__cjs$29$__["randomUUID"])() : null;
        if (persist && decisionId) {
            await persistDecision(sb, {
                id: decisionId,
                symbol,
                mode,
                timeframes,
                lookback: lookbackSummary,
                price,
                price_live: snapshot.price_live ?? null,
                gate,
                setup,
                plan,
                verdict,
                intraday: plan.intraday ?? null,
                data_health: dataHealth,
                news
            });
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: true,
            decision_id: decisionId,
            snapshot,
            gate,
            setup,
            rules: rules.map((r)=>({
                    id: r.id,
                    doc_name: r.doc_name,
                    page: r.page,
                    section: r.section,
                    chunk_type: r.chunk_type,
                    similarity: r.similarity
                })),
            plan,
            execution: computeExecutionSizing(plan, price, equity),
            intraday: plan.intraday ?? null,
            verdict,
            intradayVerdict
        }, {
            status: 200
        });
    } catch (e) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            ok: false,
            error: e?.message ?? "Unknown error"
        }, {
            status: 500
        });
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__c108875d._.js.map